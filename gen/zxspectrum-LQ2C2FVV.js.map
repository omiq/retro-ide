{
  "version": 3,
  "sources": ["../src/platform/zxspectrum.ts"],
  "sourcesContent": ["import { Platform, Preset, getToolForFilename_z80 } from '../common/baseplatform';\nimport { PLATFORMS } from '../common/emu';\n\nconst ZXSPECTRUM_PRESETS: Preset[] = [\n  { id: 'hello.bas', name: 'Hello World (BASIC)', category: 'BASIC' },\n];\n\nexport class ZXSpectrumPlatform implements Platform {\n  private mainElement: HTMLElement;\n  private iframe: HTMLIFrameElement | null = null;\n  private currentModel: '48k' | '128k' = '48k';\n  private pauseResumeSupported = true; // qaop supports pause/resume\n  sourceFileFetch?: (path: string) => any; // Set by IDE to fetch source files\n  private blobUrls: string[] = []; // Keep blob URLs alive\n  private originalBinary: Uint8Array | null = null; // Store original compiled binary for download\n  private originalFilename: string | null = null; // Store original filename for download\n\n  constructor(mainElement: HTMLElement) {\n    this.mainElement = mainElement;\n    \n    // Listen for messages from the iframe\n    window.addEventListener('message', (event) => {\n      if (event.data && event.data.type === 'emulator_capabilities') {\n        console.log(\"ZXSpectrumPlatform: Received emulator capabilities:\", event.data.capabilities);\n        \n        if (event.data.capabilities && typeof event.data.capabilities.pause === 'boolean') {\n          this.pauseResumeSupported = event.data.capabilities.pause;\n        }\n        \n        this.updateControlButtons();\n      }\n    });\n  }\n\n  async start(): Promise<void> {\n    console.log(\"ZXSpectrumPlatform start() called\");\n    \n    // Create iframe for ZX Spectrum emulator (qaop)\n    this.iframe = document.createElement('iframe');\n    this.iframe.id = 'zxspectrum-iframe';\n    this.iframe.style.width = '100%';\n    this.iframe.style.height = '600px';\n    this.iframe.style.border = '1px solid #ccc';\n    this.iframe.style.backgroundColor = '#000';\n    this.iframe.setAttribute('tabindex', '-1');\n    \n    // Prevent the IDE from pausing when clicking on the iframe\n    this.iframe.addEventListener('focus', (e) => {\n      e.stopPropagation();\n    }, true);\n    \n    this.iframe.addEventListener('click', (e) => {\n      e.stopPropagation();\n    }, true);\n    \n    // Add iframe to the main element\n    this.mainElement.innerHTML = '';\n    this.mainElement.appendChild(this.iframe);\n    \n    // Load qaop emulator\n    // Get model parameter from URL (default to 48k)\n    const urlParams = new URLSearchParams(window.location.search);\n    const modelParam = urlParams.get('model') || '48k';\n    this.currentModel = (modelParam === '128k') ? '128k' : '48k';\n    \n    const cacheBuster = `?t=${Date.now()}`;\n    const modelQuery = `&model=${encodeURIComponent(this.currentModel)}`;\n    this.iframe.src = `zxspectrum-iframe.html${cacheBuster}${modelQuery}`;\n    \n    console.log(\"ZXSpectrumPlatform: iframe created and qaop loading, model:\", this.currentModel);\n    \n    // Set up compilation listener\n    this.setupCompilationListener();\n    \n    // Update control buttons\n    this.updateControlButtons();\n  }\n\n  stop(): void {\n    console.log(\"ZXSpectrumPlatform stop() called\");\n    // qaop doesn't need explicit stop\n  }\n\n  reset(): void {\n    console.log(\"ZXSpectrumPlatform reset() called\");\n    \n    if (this.iframe && this.iframe.contentWindow) {\n      // Send reset command via postMessage to iframe wrapper\n      this.iframe.contentWindow.postMessage({ cmd: 'reset' }, '*');\n      console.log(\"ZXSpectrumPlatform: Sent reset command to iframe\");\n    }\n  }\n\n  isRunning(): boolean {\n    // qaop is always \"running\" when loaded\n    return this.iframe !== null;\n  }\n\n  getToolForFilename(filename: string): string {\n    const lowerFilename = filename.toLowerCase();\n    if (lowerFilename.endsWith('.bas')) return 'zxbasic'; // Use ZX Spectrum BASIC compiler\n    // For C files, use z88dk (which can create .tap files directly)\n    if (lowerFilename.endsWith('.c') || lowerFilename.endsWith('.h')) {\n      return 'z88dk'; // Use z88dk PHP API\n    }\n    // For Z80 assembly, use the standard Z80 toolchain\n    return getToolForFilename_z80(filename);\n  }\n\n  getDefaultExtension(): string {\n    return '.bas';\n  }\n\n  getPresets(): Preset[] {\n    return ZXSPECTRUM_PRESETS;\n  }\n\n  pause(): void {\n    if (!this.pauseResumeSupported) {\n      console.log(\"ZXSpectrumPlatform: Pause not supported\");\n      return;\n    }\n    \n    console.log(\"ZXSpectrumPlatform pause() called\");\n    \n    if (this.iframe && this.iframe.contentWindow) {\n      // qaop uses keyboard for pause, but we can try postMessage\n      this.iframe.contentWindow.postMessage({ cmd: 'pause', pause: true }, '*');\n      console.log(\"ZXSpectrumPlatform: Sent pause command to iframe\");\n    }\n  }\n\n  resume(): void {\n    if (!this.pauseResumeSupported) {\n      console.log(\"ZXSpectrumPlatform: Resume not supported\");\n      return;\n    }\n    \n    console.log(\"ZXSpectrumPlatform resume() called\");\n    \n    if (this.iframe && this.iframe.contentWindow) {\n      this.iframe.contentWindow.postMessage({ cmd: 'pause', pause: false }, '*');\n      console.log(\"ZXSpectrumPlatform: Sent resume command to iframe\");\n    }\n  }\n\n  loadROM(title: string, rom: Uint8Array | any): void {\n    console.log(\"ZXSpectrumPlatform loadROM called with title:\", title, \"rom type:\", typeof rom, \"rom length:\", rom instanceof Uint8Array ? rom.length : 'N/A');\n    \n    if (!this.iframe) {\n      console.error(\"ZXSpectrumPlatform: iframe not ready\");\n      return;\n    }\n    \n    // Store original binary for download (before any transformations)\n    if (rom instanceof Uint8Array) {\n      // Trim trailing zeros to get actual code size\n      let actualSize = rom.length;\n      for (let i = rom.length - 1; i >= 0; i--) {\n        if (rom[i] !== 0) {\n          actualSize = i + 1;\n          break;\n        }\n      }\n      \n      if (actualSize < rom.length) {\n        console.log(`ZXSpectrumPlatform: Trimming binary from ${rom.length} to ${actualSize} bytes (removed ${rom.length - actualSize} trailing zeros)`);\n        this.originalBinary = rom.slice(0, actualSize);\n      } else {\n        this.originalBinary = new Uint8Array(rom); // Make a copy\n      }\n      console.log(\"ZXSpectrumPlatform: Stored original binary for download:\", this.originalBinary.length, \"bytes\");\n    } else {\n      this.originalBinary = null;\n    }\n    \n    // Get filename for download\n    const getCurrentMainFilename = (window as any).IDE?.getCurrentMainFilename;\n    if (getCurrentMainFilename) {\n      this.originalFilename = getCurrentMainFilename();\n    } else {\n      const currentProject = (window as any).IDE?.current_project;\n      if (currentProject && currentProject.mainPath) {\n        this.originalFilename = currentProject.mainPath;\n      } else {\n        this.originalFilename = title;\n      }\n    }\n    \n    // Handle BASIC AST output - convert back to plain text\n    let dataToLoad: Uint8Array;\n    if (rom && typeof rom === 'object' && !(rom instanceof Uint8Array)) {\n      // This is likely a BASIC AST - get the original source file\n      console.log(\"ZXSpectrumPlatform: Detected BASIC AST, getting source file\");\n      \n      // Get the actual filename using multiple methods\n      let filename: string | null = null;\n      \n      // Method 1: Try getCurrentMainFilename function (reuse the one above)\n      if (getCurrentMainFilename) {\n        filename = getCurrentMainFilename();\n      }\n      \n      // Method 2: Try current_project.mainPath directly\n      if (!filename) {\n        const currentProject = (window as any).IDE?.current_project;\n        if (currentProject && currentProject.mainPath) {\n          filename = currentProject.mainPath;\n        }\n      }\n      \n      // Method 3: Try getCurrentProject().mainPath\n      if (!filename) {\n        const getCurrentProject = (window as any).IDE?.getCurrentProject;\n        if (getCurrentProject) {\n          const project = getCurrentProject();\n          if (project && project.mainPath) {\n            filename = project.mainPath;\n          }\n        }\n      }\n      \n      // Method 4: Extract from title if it looks like a filename\n      if (!filename && title && (title.includes('.') || title.length < 50)) {\n        // If title looks like a filename, use it\n        filename = title;\n      }\n      \n      if (!filename) {\n        console.warn(\"ZXSpectrumPlatform: Could not get current filename. Title was:\", title);\n        // Try to use title as filename if it looks valid\n        filename = title;\n      }\n      \n      // Try to get source file using sourceFileFetch (set by IDE) or project data\n      let sourceText: string | null = null;\n      \n      if (this.sourceFileFetch && filename) {\n        const fileData = this.sourceFileFetch(filename);\n        if (fileData && typeof fileData === 'string') {\n          sourceText = fileData;\n        }\n      }\n      \n      // Fallback: try IDE current_project directly\n      if (!sourceText) {\n        const currentProject = (window as any).IDE?.current_project;\n        if (currentProject && currentProject.filedata && filename) {\n          sourceText = currentProject.filedata[filename];\n        }\n      }\n      \n      // Fallback: try getCurrentProject\n      if (!sourceText) {\n        const getCurrentProject = (window as any).IDE?.getCurrentProject;\n        if (getCurrentProject) {\n          const project = getCurrentProject();\n          if (project && project.filedata && filename) {\n            sourceText = project.filedata[filename];\n          }\n        }\n      }\n      \n      if (sourceText && typeof sourceText === 'string') {\n        // Convert plain text BASIC to bytes\n        dataToLoad = new TextEncoder().encode(sourceText);\n        console.log(\"ZXSpectrumPlatform: Using source file text from\", filename + \",\", dataToLoad.length, \"bytes\");\n      } else {\n        console.error(\"ZXSpectrumPlatform: Could not find source file for\", filename, \"- tried sourceFileFetch and project.filedata\");\n        return;\n      }\n    } else if (rom instanceof Uint8Array) {\n      // Use the trimmed version if we have it, otherwise trim now\n      if (this.originalBinary && this.originalBinary.length < rom.length) {\n        dataToLoad = this.originalBinary;\n        console.log(\"ZXSpectrumPlatform: Using trimmed binary data,\", dataToLoad.length, \"bytes (original was\", rom.length, \"bytes)\");\n      } else {\n        dataToLoad = rom;\n        console.log(\"ZXSpectrumPlatform: Using binary data,\", dataToLoad.length, \"bytes\");\n      }\n    } else {\n      console.error(\"ZXSpectrumPlatform: Unexpected rom type:\", typeof rom);\n      return;\n    }\n    \n    // Create a blob URL for the data with proper content type\n    // qaop recognizes these content types:\n    // - application/x.zx.tap for TAP files\n    // - application/x.zx.rom for ROM images\n    // - application/x.zx.sna for SNA snapshots\n    // - application/x.zx.z80 for Z80 snapshots\n    // - image/x.zx.scr for screens\n    \n    // Detect file type from data or filename\n    // Get filename to help with detection (reuse getCurrentMainFilename from above)\n    let filename: string | null = null;\n    if (getCurrentMainFilename) {\n      filename = getCurrentMainFilename();\n    }\n    if (!filename) {\n      const currentProject = (window as any).IDE?.current_project;\n      if (currentProject && currentProject.mainPath) {\n        filename = currentProject.mainPath;\n      }\n    }\n    \n    let contentType = 'application/x.zx.tap'; // Default to TAP\n    if (dataToLoad.length > 0) {\n      // Check for TAP file (starts with 0x13 for header block)\n      // z88dk outputs .tap files directly, so if it's already a TAP file, use it as-is\n      if (dataToLoad[0] === 0x13) {\n        contentType = 'application/x.zx.tap';\n        console.log(\"ZXSpectrumPlatform: TAP file detected (likely from z88dk), using as-is\");\n      }\n      // Check for Z80 snapshot (starts with 0x03 0x00)\n      else if (dataToLoad.length > 30 && dataToLoad[0] === 0x03 && dataToLoad[1] === 0x00) {\n        contentType = 'application/x.zx.z80';\n      }\n      // Check for SNA snapshot (starts with specific header)\n      else if (dataToLoad.length > 27 && dataToLoad[0] === 0x3F) {\n        contentType = 'application/x.zx.sna';\n      }\n      // If it's not a recognized format and it's a C file, z88dk should have output a TAP file\n      // But if we get here, it might be a raw binary - check if we should wrap it\n      else if (filename && (filename.endsWith('.c') || filename.endsWith('.C'))) {\n        // z88dk should output .tap files, but if we get a raw binary, wrap it in TAP CODE block\n        console.log(\"ZXSpectrumPlatform: C program binary detected (not TAP), wrapping in CODE block\");\n        const baseFilename = filename.split('/').pop()?.replace(/\\.[^.]*$/, '') || 'PROGRAM';\n        dataToLoad = this.createCodeTAPFile(dataToLoad, baseFilename, 0x8000);\n        contentType = 'application/x.zx.tap';\n      }\n      // If it's a large binary file (> 1KB) and doesn't match other formats, wrap as CODE\n      else if (dataToLoad.length > 1024) {\n        // Assume it's a compiled binary, wrap in TAP with CODE block\n        const baseFilename = filename ? filename.split('/').pop()?.replace(/\\.[^.]*$/, '') || 'PROGRAM' : 'PROGRAM';\n        dataToLoad = this.createCodeTAPFile(dataToLoad, baseFilename, 0x8000);\n        contentType = 'application/x.zx.tap';\n      }\n    }\n    \n    // Use data URL instead of blob URL to avoid cross-origin issues with nested iframes\n    // Convert binary data to base64 using chunked approach for large arrays\n    let base64Data: string;\n    if (dataToLoad.length > 65536) {\n      // For very large arrays, convert in chunks to avoid stack overflow\n      const chunks: string[] = [];\n      for (let i = 0; i < dataToLoad.length; i += 8192) {\n        const chunk = dataToLoad.slice(i, Math.min(i + 8192, dataToLoad.length));\n        chunks.push(String.fromCharCode(...chunk));\n      }\n      base64Data = btoa(chunks.join(''));\n    } else {\n      base64Data = btoa(String.fromCharCode(...dataToLoad));\n    }\n    const dataUrl = `data:${contentType};base64,${base64Data}`;\n    \n    console.log(\"ZXSpectrumPlatform: Created data URL with content type:\", contentType);\n    console.log(\"ZXSpectrumPlatform: Data URL length:\", dataUrl.length, \"bytes (original:\", dataToLoad.length, \"bytes)\");\n    \n    // Send load command via postMessage to iframe wrapper\n    // The iframe wrapper will handle loading into qaop via URL hash\n    // We need to wait a bit for the iframe to be ready\n    const sendLoad = () => {\n      if (this.iframe && this.iframe.contentWindow) {\n        // Get filename for CODE block detection (reuse filename from above)\n        let detectedFilename: string | null = filename;\n        if (!detectedFilename && getCurrentMainFilename) {\n          detectedFilename = getCurrentMainFilename();\n        }\n        if (!detectedFilename) {\n          const currentProject = (window as any).IDE?.current_project;\n          if (currentProject && currentProject.mainPath) {\n            detectedFilename = currentProject.mainPath;\n          }\n        }\n        \n        console.log(\"ZXSpectrumPlatform: Sending load command, filename:\", detectedFilename, \"contentType:\", contentType);\n        this.iframe.contentWindow.postMessage({ \n          cmd: 'load',\n          url: dataUrl,\n          contentType: contentType, // Pass content type to iframe\n          data: Array.from(dataToLoad), // Also send data directly in case qaop supports it\n          filename: detectedFilename // Pass filename to help detect CODE blocks\n        }, '*');\n        console.log(\"ZXSpectrumPlatform: Sent load command to iframe with data URL and content type:\", contentType);\n      } else {\n        console.warn(\"ZXSpectrumPlatform: Iframe not ready, retrying...\");\n        setTimeout(sendLoad, 100);\n      }\n    };\n    \n    // Wait a bit for iframe to be ready, then send\n    setTimeout(sendLoad, 100);\n  }\n\n  getROMExtension(rom?: Uint8Array): string {\n    // Check if it's a TAP file (starts with header block flag 0x13)\n    if (rom && rom.length > 0 && rom[0] === 0x13) {\n      return '.tap';\n    }\n    // Check if it's a Z80 snapshot (starts with specific header)\n    if (rom && rom.length > 30 && rom[0] === 0x03 && rom[1] === 0x00) {\n      return '.z80';\n    }\n    // For compiled C binaries, return .bin (they are raw binaries)\n    // Check filename to determine if it's a C file\n    let filename: string | null = null;\n    const getCurrentMainFilenameFn = (window as any).IDE?.getCurrentMainFilename;\n    if (getCurrentMainFilenameFn) {\n      filename = getCurrentMainFilenameFn();\n    }\n    if (!filename) {\n      const currentProject = (window as any).IDE?.current_project;\n      if (currentProject && currentProject.mainPath) {\n        filename = currentProject.mainPath;\n      }\n    }\n    if (filename && (filename.endsWith('.c') || filename.endsWith('.C'))) {\n      return '.z80'; // C files are wrapped in Z80 snapshot format, so use .z80 extension\n    }\n    // Default to .tap for ZX Spectrum\n    return '.tap';\n  }\n\n  /**\n   * Create a TAP file with a CODE block for machine code programs\n   * TAP format for CODE blocks:\n   * - Header block: flag (0x13) + length (2 bytes) + header data (17 bytes) + checksum\n   *   - Header data: type (0x03 = code), filename (10 bytes), data length (2 bytes),\n   *     parameter 1 (start address, 2 bytes), parameter 2 (unused, 2 bytes)\n   * - Data block: flag (0xFF) + length (2 bytes) + code data + checksum\n   */\n  private createCodeTAPFile(code: Uint8Array, filename: string, startAddress: number): Uint8Array {\n    const baseFilename = filename.split('/').pop()?.replace(/\\.[^.]*$/, '') || 'PROGRAM';\n    const filenameBytes = new Uint8Array(10);\n    filenameBytes.fill(0x20); // Fill with spaces\n    for (let i = 0; i < Math.min(baseFilename.length, 10); i++) {\n      filenameBytes[i] = baseFilename.toUpperCase().charCodeAt(i);\n    }\n\n    const codeLength = code.length;\n\n    // Header data block (17 bytes)\n    const headerData = new Uint8Array(17);\n    headerData[0] = 0x03; // Type: code (0x03 = code block)\n    headerData.set(filenameBytes, 1); // Filename (10 bytes)\n    headerData[11] = codeLength & 0xFF; // Data length low\n    headerData[12] = (codeLength >> 8) & 0xFF; // Data length high\n    headerData[13] = startAddress & 0xFF; // Parameter 1 (start address) low\n    headerData[14] = (startAddress >> 8) & 0xFF; // Parameter 1 (start address) high\n    headerData[15] = 0x80; // Parameter 2 low (unused, often 0x80)\n    headerData[16] = 0x00; // Parameter 2 high (unused)\n\n    // Calculate header checksum (XOR of all 17 header data bytes)\n    let headerChecksum = 0;\n    for (let i = 0; i < 17; i++) {\n      headerChecksum ^= headerData[i];\n    }\n\n    // Create header block: flag (1) + length (2) + data (17) + checksum (1) = 21 bytes\n    // For CODE blocks, the length should be 0x11 (17 bytes) - different from BASIC which uses 0x00 0x00\n    const headerBlock = new Uint8Array(1 + 2 + 17 + 1);\n    headerBlock[0] = 0x13; // Flag byte for header block\n    headerBlock[1] = 0x11; // Length low (17 bytes = 0x11)\n    headerBlock[2] = 0x00; // Length high (0x00)\n    headerBlock.set(headerData, 3); // Data (17 bytes)\n    headerBlock[3 + 17] = headerChecksum; // Checksum\n\n    // Create data block: flag + length + data + checksum\n    const dataBlock = new Uint8Array(1 + 2 + codeLength + 1);\n    dataBlock[0] = 0xFF; // Flag byte for data\n    dataBlock[1] = codeLength & 0xFF; // Length low\n    dataBlock[2] = (codeLength >> 8) & 0xFF; // Length high\n    dataBlock.set(code, 3); // Code data\n\n    // Calculate data block checksum (XOR of flag, length bytes, and all data bytes)\n    let dataChecksum = 0xFF; // Start with flag byte\n    dataChecksum ^= (codeLength & 0xFF);\n    dataChecksum ^= ((codeLength >> 8) & 0xFF);\n    for (let i = 0; i < codeLength; i++) {\n      dataChecksum ^= code[i];\n    }\n    dataBlock[3 + codeLength] = dataChecksum;\n\n    // Combine header and data block\n    const tapFile = new Uint8Array(headerBlock.length + dataBlock.length);\n    tapFile.set(headerBlock, 0);\n    tapFile.set(dataBlock, headerBlock.length);\n\n    return tapFile;\n  }\n\n  private getFileType(filename: string): string {\n    const lower = filename.toLowerCase();\n    if (lower.endsWith('.tap')) return 'tap';\n    if (lower.endsWith('.z80')) return 'z80';\n    if (lower.endsWith('.sna')) return 'sna';\n    if (lower.endsWith('.rom')) return 'rom';\n    if (lower.endsWith('.scr')) return 'scr';\n    return 'tap'; // default\n  }\n\n  private setupCompilationListener(): void {\n    // Listen for compilation events from the IDE\n    const originalSetCompileOutput = (window as any).setCompileOutput;\n    if (originalSetCompileOutput) {\n      (window as any).setCompileOutput = (data: any) => {\n        // Call the original function\n        originalSetCompileOutput(data);\n        \n        // If compilation was successful, reload the program\n        if (data && data.output && !data.errors) {\n          console.log(\"ZXSpectrumPlatform: Compilation detected, reloading program\");\n          // The compiled output should be available in data.output\n          // We'll need to handle this based on the compilation tool used\n        }\n      };\n    }\n  }\n\n  private updateControlButtons(): void {\n    // Update UI control buttons visibility based on capabilities\n    // This would typically update buttons in the IDE UI\n    const pauseButton = document.querySelector('[data-action=\"pause\"]') as HTMLElement;\n    const resumeButton = document.querySelector('[data-action=\"resume\"]') as HTMLElement;\n    \n    if (pauseButton) {\n      pauseButton.style.display = this.pauseResumeSupported ? '' : 'none';\n    }\n    if (resumeButton) {\n      resumeButton.style.display = this.pauseResumeSupported ? '' : 'none';\n    }\n  }\n\n  getDownloadFile(): { extension: string, blob: Blob } | undefined {\n    // Return the original compiled binary (not the Z80 snapshot)\n    if (this.originalBinary) {\n      console.log(\"ZXSpectrumPlatform: getDownloadFile() called, returning original binary:\", this.originalBinary.length, \"bytes\");\n      \n      // Determine extension based on filename\n      let extension = '.bin'; // Default\n      if (this.originalFilename) {\n        const lowerFilename = this.originalFilename.toLowerCase();\n        if (lowerFilename.endsWith('.bas')) {\n          extension = '.tap'; // BASIC programs are tokenized to TAP\n        } else if (lowerFilename.endsWith('.c')) {\n          extension = '.bin'; // C programs are raw binaries\n        } else {\n          // Use getROMExtension to determine based on content\n          extension = this.getROMExtension(this.originalBinary);\n        }\n      } else {\n        // Fallback: check content\n        extension = this.getROMExtension(this.originalBinary);\n      }\n      \n      const blob = new Blob([this.originalBinary], { type: \"application/octet-stream\" });\n      return {\n        extension: extension,\n        blob: blob\n      };\n    }\n    \n    console.log(\"ZXSpectrumPlatform: getDownloadFile() called, but no original binary available\");\n    return undefined;\n  }\n\n  // Optional methods that may be called by the IDE\n  loadState?(state: any): void {\n    // qaop supports state saving/loading but we'd need to implement this\n    console.log(\"ZXSpectrumPlatform: loadState not yet implemented\");\n  }\n\n  saveState?(): any {\n    // qaop supports state saving/loading but we'd need to implement this\n    console.log(\"ZXSpectrumPlatform: saveState not yet implemented\");\n    return null;\n  }\n\n  /**\n   * Create a Z80 snapshot file from compiled binary code\n   * Z80 format v1 (48k): 30-byte header + compressed RAM blocks\n   * This creates a snapshot with the program loaded at startAddress and PC set to startAddress\n   */\n  private createZ80Snapshot(code: Uint8Array, startAddress: number): Uint8Array {\n    // Z80 v2/v3 format with extended header (PC=0 in main header, PC in extended header)\n    // This matches the format that qaop uses when saving snapshots\n    const header = new Uint8Array(30);\n    \n    // Registers\n    header[0] = 0x00; // A\n    header[1] = 0x00; // F (flags)\n    header[2] = 0x00; // BC low\n    header[3] = 0x00; // BC high\n    header[4] = 0x00; // HL low\n    header[5] = 0x00; // HL high\n    header[6] = 0x00; // PC low (0 = extended header format)\n    header[7] = 0x00; // PC high (0 = extended header format)\n    // Stack pointer: ZX Spectrum typically uses 0xFF58 or higher\n    // But we'll use 0xFF00 which should be safe\n    header[8] = 0x00; // SP low (stack pointer at 0xFF00)\n    header[9] = 0xFF; // SP high\n    header[10] = 0x00; // I (interrupt register)\n    header[11] = 0x00; // R (refresh register)\n    \n    // Flags byte (byte 12)\n    // Bit 0: R bit 7\n    // Bit 1-3: Border color (0-7)\n    // Bit 4: SamRom\n    // Bit 5: Compressed (1 = compressed, 0 = uncompressed)\n    // Try uncompressed first to avoid compression bugs\n    header[12] = 0x00; // Uncompressed data (bit 5 = 0)\n    \n    // DE register\n    header[13] = 0x00; // DE low\n    header[14] = 0x00; // DE high\n    \n    // Alternate registers\n    header[15] = 0x00; // BC' low\n    header[16] = 0x00; // BC' high\n    header[17] = 0x00; // DE' low\n    header[18] = 0x00; // DE' high\n    header[19] = 0x00; // HL' low\n    header[20] = 0x00; // HL' high\n    header[21] = 0x00; // A'\n    header[22] = 0x00; // F'\n    \n    // IY and IX\n    // IY must point to system variables area (0x5C3A) for ZX Spectrum BASIC system calls\n    header[23] = 0x3A; // IY low (0x5C3A = system variables)\n    header[24] = 0x5C; // IY high\n    header[25] = 0x00; // IX low\n    header[26] = 0x00; // IX high\n    \n    // Interrupt flags\n    header[27] = 0x00; // IFF1 (0 = DI, 1 = EI)\n    header[28] = 0x00; // IFF2\n    header[29] = 0x00; // IM (interrupt mode: 0, 1, or 2)\n    \n    // Set up basic state for program execution\n    header[27] = 0x01; // IFF1 = 1 (EI)\n    header[28] = 0x01; // IFF2 = 1\n    header[29] = 0x01; // IM = 1\n    \n    // Extended header - required when PC=0 in main header\n    // Format: [length_low] [length_high] [23 bytes of data]\n    // The extended header data starts with PC, then other registers/state\n    const extendedHeaderData = new Uint8Array(23);\n    extendedHeaderData[0] = startAddress & 0xFF; // PC low\n    extendedHeaderData[1] = (startAddress >> 8) & 0xFF; // PC high\n    // Rest is zeros (reserved/padding)\n    \n    // Extended header with length prefix (2 bytes + 23 bytes = 25 bytes total)\n    const extendedHeader = new Uint8Array(25);\n    extendedHeader[0] = 23 & 0xFF; // Length low (23 bytes)\n    extendedHeader[1] = (23 >> 8) & 0xFF; // Length high (0)\n    extendedHeader.set(extendedHeaderData, 2);\n    \n    // Create RAM image (48k = 49152 bytes)\n    // Memory map:\n    // 0x0000-0x3FFF: ROM (not included in snapshot)\n    // 0x4000-0x5AFF: Screen RAM (0x1B00 bytes)\n    // 0x5B00-0x5BFF: Color RAM (0x100 bytes)\n    // 0x5C00-0x5CFF: System variables (0x100 bytes)\n    // 0x5D00-0xFF57: User RAM\n    // 0xFF58-0xFFFF: System stack\n    \n    const ram = new Uint8Array(49152);\n    \n    // Initialize screen RAM with default values (black border, white paper)\n    for (let i = 0; i < 0x1B00; i++) {\n      ram[i] = 0x00; // Screen RAM (0x4000-0x5AFF)\n    }\n    \n    // Initialize color RAM (0x5B00-0x5BFF)\n    for (let i = 0x1B00; i < 0x1C00; i++) {\n      ram[i] = 0x47; // White paper, black ink, bright\n    }\n    \n    // Initialize system variables area (0x5C00-0x5CFF)\n    for (let i = 0x1C00; i < 0x1D00; i++) {\n      ram[i] = 0x00;\n    }\n    \n    // Load the compiled code at startAddress (0x8000 = offset 0x4000 in RAM)\n    const codeOffset = startAddress - 0x4000;\n    if (codeOffset >= 0 && codeOffset + code.length <= ram.length) {\n      ram.set(code, codeOffset);\n    } else {\n      console.warn(`ZXSpectrumPlatform: Code doesn't fit in RAM at address 0x${startAddress.toString(16)}`);\n    }\n    \n    // Z80 v2/v3 format (48k): After the 30-byte header and extended header, RAM is saved in 3 blocks\n    // Each block is 16384 bytes, compressed, and prefixed with a 2-byte length\n    // Block 0: 0x4000-0x7FFF (offset 0-16383 in ram array)\n    // Block 1: 0x8000-0xBFFF (offset 16384-32767 in ram array)\n    // Block 2: 0xC000-0xFFFF (offset 32768-49151 in ram array)\n    \n    // Compression flag is already set in header[12] above (bit 5 = 0x20)\n    \n    const blocks: Uint8Array[] = [];\n    \n    // Save each RAM block (uncompressed for now to avoid compression bugs)\n    for (let blockNum = 0; blockNum < 3; blockNum++) {\n      const blockStart = blockNum * 16384;\n      const blockEnd = blockStart + 16384;\n      const blockData = ram.slice(blockStart, blockEnd);\n      \n      // For uncompressed format, the block length is 0xFFFF (65535) followed by the data\n      // But actually, uncompressed blocks are just the raw data prefixed with length\n      // Length should be 0x4000 (16384) for uncompressed blocks\n      const blockLength = blockData.length; // 16384\n      const blockWithLength = new Uint8Array(2 + blockLength);\n      blockWithLength[0] = blockLength & 0xFF;\n      blockWithLength[1] = (blockLength >> 8) & 0xFF;\n      blockWithLength.set(blockData, 2);\n      \n      blocks.push(blockWithLength);\n    }\n    \n    // Calculate total size: header (30) + extended header length prefix (2) + extended header data (23) + RAM blocks\n    let totalSize = header.length + extendedHeader.length;\n    for (const block of blocks) {\n      totalSize += block.length;\n    }\n    \n    // Combine header, extended header (with length prefix), and RAM blocks\n    const snapshot = new Uint8Array(totalSize);\n    snapshot.set(header, 0);\n    snapshot.set(extendedHeader, header.length);\n    let offset = header.length + extendedHeader.length;\n    for (const block of blocks) {\n      snapshot.set(block, offset);\n      offset += block.length;\n    }\n    \n    console.log(`ZXSpectrumPlatform: Created Z80 snapshot: ${snapshot.length} bytes (header: ${header.length}, blocks: ${blocks.map(b => b.length).join(', ')})`);\n    \n    return snapshot;\n  }\n\n  /**\n   * Compress RAM data for Z80 snapshot format\n   * Compression algorithm:\n   * - If byte is 0xED, escape as 0xED 0xED 0x00\n   * - If 4+ consecutive identical bytes, compress as 0xED 0xED count byte\n   * - Otherwise output byte as-is\n   */\n  private compressZ80RAM(ram: Uint8Array): Uint8Array {\n    const output: number[] = [];\n    let i = 0;\n    \n    while (i < ram.length) {\n      const byte = ram[i];\n      \n      // Special case: 0xED must be escaped first\n      if (byte === 0xED) {\n        // Check if next byte is also 0xED (compression marker)\n        if (i + 1 < ram.length && ram[i + 1] === 0xED) {\n          // This is a compression marker, escape it\n          output.push(0xED, 0xED, 0x00);\n          i++;\n        } else {\n          // Single 0xED byte, escape it\n          output.push(0xED, 0xED, 0x00);\n        }\n        i++;\n        continue;\n      }\n      \n      // Count consecutive identical bytes\n      let count = 1;\n      while (i + count < ram.length && ram[i + count] === byte && count < 255) {\n        count++;\n      }\n      \n      if (count >= 4) {\n        // Compress: ED ED count byte\n        output.push(0xED, 0xED, count, byte);\n        i += count;\n      } else {\n        // No compression: just output the bytes\n        for (let j = 0; j < count; j++) {\n          output.push(ram[i + j]);\n        }\n        i += count;\n      }\n    }\n    \n    return new Uint8Array(output);\n  }\n}\n\n// Register the platform\nPLATFORMS['zxspectrum'] = ZXSpectrumPlatform;\n\n// Export for dynamic loading\nexport default ZXSpectrumPlatform;\n\n"],
  "mappings": "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",
  "names": []
}
