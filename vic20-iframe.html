<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>VIC-20 Emulator (Iframe)</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            background-color: #000;
            font-family: monospace;
            overflow: hidden;
            display: flex;
            align-items: center;
            justify-content: center;
            height: 100vh;
        }
        
        #canvas-container {

            max-height: 100%;
            max-width: 100%;
            aspect-ratio: 600 / 400;
            width: 600px;
          
            display: flex;
            align-items: center;
            justify-content: center;
            background-color: #000;
        }
        
        #canvas {
            border: 1px solid #333;
            aspect-ratio: 600 / 400;
            max-width: 100%;
            max-height: 100%;
            cursor: pointer;
            outline: none;
            display: block;
            width: 600px;
            
            /* image-rendering: pixelated; */
            /* image-rendering: -moz-crisp-edges;
            image-rendering: crisp-edges; */
        }
        
        #canvas:focus {
            border: 2px solid #4CAF50;
        }
        
        .status {
            position: fixed;
            top: 10px;
            left: 10px;
            color: white;
            background: rgba(0,0,0,0.7);
            padding: 5px 10px;
            border-radius: 4px;
            font-size: 12px;
            max-width: 300px;
            word-wrap: break-word;
        }
    </style>
</head>
<body>
    <div class="status" id="status">Loading VIC-20 emulator...</div>
    <div id="canvas-container">
        <canvas id="canvas" width="416" height="528" tabindex="0"></canvas>
    </div>

    <script>
        // This iframe has its own isolated window object
        // No conflicts with the main application's event handling
        
        // Define callbacks at the top level so they're available immediately when WASM loads
        // These must be defined before the emscripten module script loads
        
        // Video callback - called by WASM to update the screen
        const SCREEN_W = 208;
        const SCREEN_H = 264;
        const PIXEL_WIDTH = 2;
        
        // Canvas resize function disabled - canvas will use CSS for sizing
        
        window.m6561_screen_update = function(ptr) {
            const instance = typeof wasm_instance !== 'undefined' ? wasm_instance : 
                            (typeof window.wasm_instance !== 'undefined' ? window.wasm_instance : null);
            
            if (!instance || !instance.HEAPU8) {
                return; // WASM not ready yet
            }
            
            const canvas = document.getElementById('canvas');
            if (!canvas) return;
            
            const ctx = canvas.getContext('2d');
            if (!ctx) return;
            
            // Get pixel data from WASM memory
            const size = SCREEN_W * SCREEN_H * 4 * PIXEL_WIDTH * PIXEL_WIDTH;
            const heap = instance.HEAPU8.subarray(ptr, ptr + size);
            const data = new Uint8ClampedArray(heap);
            const img = new ImageData(data, SCREEN_W * PIXEL_WIDTH, SCREEN_H * PIXEL_WIDTH);
            
            // Draw to canvas
            ctx.putImageData(img, 0, 0);
        };
        
        // Audio callback - called by WASM when audio samples are ready
        const AUDIO_BUFSIZE = 1024; // Must match the C code
        let audio_buffers_queue = [];
        
        window.audio_buf_ready = function(ptr, size) {
            const instance = typeof wasm_instance !== 'undefined' ? wasm_instance : 
                            (typeof window.wasm_instance !== 'undefined' ? window.wasm_instance : null);
            
            if (!instance || !instance.HEAPF32) {
                return; // WASM not ready yet
            }
            
            // Read audio samples from WASM memory (Float32 array)
            const start = ptr / instance.HEAPF32.BYTES_PER_ELEMENT;
            const buffer = instance.HEAPF32.subarray(start, start + size);
            
            // Push a cloned copy to the queue (audio processing happens asynchronously)
            audio_buffers_queue.push([...buffer]);
            
            // Limit queue size to prevent memory issues
            if (audio_buffers_queue.length > 10) {
                audio_buffers_queue = audio_buffers_queue.slice(-5); // Keep last 5
            }
        };
        
        const canvas = document.getElementById('canvas');
        const status = document.getElementById('status');
        
        let emulatorReady = false;
        let lastCompiledProgram = null;
        
        function updateStatus(message) {
            status.textContent = message;
            console.log("VIC-20 iframe:", message);
        }
        
        // Helper function to type text into the emulator using the fork's approach
        function typeTextIntoEmulator(text) {
            if (!window.vic20 || !window.vic20.poke) {
                console.error("VIC-20 iframe: Cannot type - emulator not ready");
                return;
            }
            
            console.log("üéØ Typing text into emulator:", text);
            
            // Use the fork's pasteChar approach: write directly to keyboard buffer
            // Address 631 is the keyboard buffer, address 198 is the buffer length
            let charIndex = 0;
            
            function pasteNextChar() {
                if (charIndex >= text.length) {
                    console.log("‚úÖ Finished typing text");
                    updateStatus("Text typed into emulator");
                    return;
                }
                
                const char = text[charIndex];
                const charCode = char.charCodeAt(0);
                
                // Wait for keyboard buffer to be empty (address 198 = 0)
                if (window.vic20.peek && window.vic20.peek(198) !== 0) {
                    // Buffer not empty, wait a bit and try again
                    // Don't call exec_us here - let the main loop handle emulation
                    // This prevents blocking the browser thread
                    setTimeout(pasteNextChar, 50);
                    return;
                }
                
                // Write character to keyboard buffer (address 631)
                window.vic20.poke(631, charCode);
                // Set buffer length to 1 (address 198)
                window.vic20.poke(198, 1);
                
                charIndex++;
                
                // Small delay before next character
                setTimeout(pasteNextChar, 50);
            }
            
            // Start typing
            pasteNextChar();
        }
        
        // Core function to load program into emulator using the new emulator's load_prg function
        function loadProgramIntoEmulator(programData) {
            if (!emulatorReady || !programData) {
                updateStatus("Emulator not ready or no program available");
                return;
            }
            
            updateStatus("Loading program into emulator...");
            
            try {
                // Use the new emulator's load_prg function which properly sets BASIC pointers
                if (window.vic20 && typeof window.vic20.load_prg === 'function') {
                    console.log("üéØ Loading program using vic20.load_prg()...");
                    console.log("üéØ Program data length:", programData.length, "bytes");
                    
                    // Convert Uint8Array to regular array for the emulator
                    const buffer = Array.from(programData);
                    
                    // Load the program - this properly sets BASIC pointers automatically
                    window.vic20.load_prg(buffer, programData.length);
                    
                    console.log("‚úÖ Program loaded via vic20.load_prg()");
                    updateStatus("Program loaded: " + programData.length + " bytes");
                    
                    // Verify and fix BASIC pointers if needed (address 43-44 for start, 45-46 for end)
                    // Address 43-44 contains the start of BASIC program (low byte, high byte)
                    // With unexpanded: 0x1001, with +8K expansion: 0x1201
                    setTimeout(() => {
                        if (window.vic20 && window.vic20.peek && window.vic20.poke && programData.length >= 2) {
                            const loadAddress = (programData[1] << 8) | programData[0];
                            const programLength = programData.length - 2; // Exclude PRG header
                            const programEnd = loadAddress + programLength;
                            
                            const basicStartLow = window.vic20.peek(43);
                            const basicStartHigh = window.vic20.peek(44);
                            const basicStart = basicStartLow + (basicStartHigh * 256);
                            
                            console.log("üéØ Program load address:", "0x" + loadAddress.toString(16));
                            console.log("üéØ Program end address:", "0x" + programEnd.toString(16));
                            console.log("üéØ BASIC start pointer (before fix):", "0x" + basicStart.toString(16), "(" + basicStart + ")");
                            
                            // Check if this looks like a BASIC program (starts with a line structure)
                            // BASIC programs have: [next_line_low, next_line_high, line_num_low, line_num_high, ...]
                            const isBasicProgram = programLength >= 4 && 
                                loadAddress >= 0x1001 && loadAddress <= 0x1FFF; // Valid BASIC memory range
                            
                            // If BASIC start pointer is 0 or doesn't match load address, fix it
                            if (isBasicProgram && (basicStart === 0 || basicStart !== loadAddress)) {
                                console.log("üîß Fixing BASIC pointers...");
                                // Set BASIC start pointer (address 43-44)
                                window.vic20.poke(43, loadAddress & 0xFF);
                                window.vic20.poke(44, (loadAddress >> 8) & 0xFF);
                                // Set BASIC end pointer (address 45-46)
                                window.vic20.poke(45, programEnd & 0xFF);
                                window.vic20.poke(46, (programEnd >> 8) & 0xFF);
                                
                                const newBasicStart = window.vic20.peek(43) + (window.vic20.peek(44) * 256);
                                console.log("‚úÖ BASIC start pointer fixed to:", "0x" + newBasicStart.toString(16));
                            } else if (basicStart === loadAddress || basicStart === 0x1001 || (basicStart > 0x1000 && basicStart <= 0xFFFF)) {
                                console.log("‚úÖ Program appears to be loaded correctly");
                            } else if (basicStart === 0) {
                                console.log("‚ÑπÔ∏è BASIC start pointer is 0 - this is normal for pure machine code programs");
                            } else {
                                console.warn("‚ö†Ô∏è BASIC start pointer unexpected:", basicStart, "expected around", loadAddress);
                            }
                        }
                    }, 200);
                    
                    // Type RUN command to execute the program
                    // Wait longer to ensure program is fully loaded and emulator is ready
                    setTimeout(() => {
                        console.log("üéØ Typing RUN command...");
                        typeTextIntoEmulator("RUN\r");
                    }, 1000);
                } else {
                    updateStatus("vic20.load_prg not available");
                    console.error("‚ùå vic20.load_prg function not available");
                }
            } catch (e) {
                updateStatus("Error loading program: " + e.message);
                console.error("Error loading program:", e);
            }
        }
        
        // Initialize VIC-20 emulator using the new fork's emulator
        async function initVIC20Emulator() {
            updateStatus("Loading VIC-20 emulator...");
            
            try {
                // Configure WASM file path BEFORE loading the script
                // The emscripten module will use this to find the WASM file
                if (typeof window.Module === 'undefined') {
                    window.Module = {};
                }
                window.Module.locateFile = function(path, prefix) {
                    if (path.endsWith('.wasm')) {
                        // The emscripten module expects 'emscripten_module.wasm'
                        // Use relative path (same as C64 iframe) to match server structure
                        return 'res/emscripten_module.wasm';
                    }
                    return (prefix || '') + path;
                };
                
                // Callbacks are already defined at the top level, so they're available immediately
                
                // Set up basic audio output (optional - can be disabled if not needed)
                let audioContext = null;
                let speakerSound = null;
                let audio_playing = false;
                
                try {
                    audioContext = new (window.AudioContext || window.webkitAudioContext)();
                    speakerSound = audioContext.createScriptProcessor(AUDIO_BUFSIZE, 1, 1);
                    
                    speakerSound.onaudioprocess = function(e) {
                        const output = e.outputBuffer.getChannelData(0);
                        
                        if (audio_buffers_queue.length === 0) {
                            // No audio data available, output silence
                            for (let i = 0; i < AUDIO_BUFSIZE; i++) {
                                output[i] = 0;
                            }
                            return;
                        }
                        
                        const buffer = audio_buffers_queue[0];
                        audio_buffers_queue = audio_buffers_queue.slice(1);
                        
                        for (let i = 0; i < Math.min(buffer.length, AUDIO_BUFSIZE); i++) {
                            output[i] = buffer[i];
                        }
                    };
                    
                    // Auto-start audio on first user interaction
                    const startAudio = () => {
                        if (!audio_playing && audioContext && speakerSound) {
                            speakerSound.connect(audioContext.destination);
                            audio_playing = true;
                            audio_buffers_queue = [];
                            // Remove listeners after first start
                            document.removeEventListener('click', startAudio);
                            document.removeEventListener('keydown', startAudio);
                        }
                    };
                    
                    document.addEventListener('click', startAudio, { once: true });
                    document.addEventListener('keydown', startAudio, { once: true });
                } catch (e) {
                    console.warn("VIC-20 iframe: Audio context not available:", e);
                    // Audio is optional, continue without it
                }
                
                // Load the emscripten module script
                // Use relative path (same as C64 iframe) to match server structure
                const moduleScript = document.createElement('script');
                moduleScript.src = 'res/vic20-emu.js';
                
                await new Promise((resolve, reject) => {
                    moduleScript.onload = resolve;
                    moduleScript.onerror = () => reject(new Error("Failed to load res/vic20-emu.js"));
                    document.head.appendChild(moduleScript);
                });
                
                updateStatus("VIC-20 module script loaded");
                
                // Load the wrapper script which sets up the vic20 object
                // Use relative path (same as C64 iframe) to match server structure
                const wrapperScript = document.createElement('script');
                wrapperScript.src = 'res/vic20-emu-wrapper.js';
                
                await new Promise((resolve, reject) => {
                    wrapperScript.onload = resolve;
                    wrapperScript.onerror = () => reject(new Error("Failed to load res/vic20-emu-wrapper.js"));
                    document.head.appendChild(wrapperScript);
                });
                
                updateStatus("VIC-20 wrapper script loaded");
                
                // Now load the WASM module and initialize
                if (typeof load_wasm === 'function') {
                    await load_wasm();
                    updateStatus("VIC-20 WASM module loaded");
                    
                    // The wrapper should have assigned vic20 to window.vic20
                    // Initialize the emulator
                    if (window.vic20 && typeof window.vic20.init === 'function') {
                        // Set canvas size to match VIC-20 screen (208x264 pixels, 2x scale)
                        canvas.width = 208 * 2;
                        canvas.height = 264 * 2;
                        
                        // Clear canvas with black background
                        const ctx = canvas.getContext('2d');
                        if (ctx) {
                            ctx.fillStyle = 'black';
                            ctx.fillRect(0, 0, canvas.width, canvas.height);
                        }
                        
                        // Initialize the emulator
                        window.vic20.init();
                        updateStatus("VIC-20 emulator initialized");
                        
                        // Reset the emulator to ensure clean state
                        if (typeof window.vic20.reset === 'function') {
                            window.vic20.reset();
                        }
                        
                        // Configure memory expansion from URL parameter (optional)
                        // If not provided, load_prg() will handle it automatically (like drag-and-drop does)
                        // config values: 0=unexpanded, 1=+3K, 2=+8K, 3=+16K, 4=+24K, 5=+8K (alternative)
                        const urlParams = new URLSearchParams(window.location.search);
                        const memoryConfig = urlParams.get('memory');
                        if (memoryConfig !== null && typeof window.vic20.config === 'function') {
                            const parsed = parseInt(memoryConfig, 10);
                            if (!isNaN(parsed) && parsed >= 0 && parsed <= 5) {
                                console.log(`VIC-20 iframe: Setting memory config to ${parsed}`);
                                window.vic20.config(parsed);
                            }
                        } else {
                            console.log("VIC-20 iframe: No memory config specified, letting load_prg() handle it automatically");
                        }
                        
                        // Set up main emulation loop
                        let lastTimestamp = performance.now();
                        let animationFrameId = null;
                        let isPaused = false;
                        let accumulatedTime = 0;
                        
                        function oneFrame(timestamp) {
                            if (isPaused) {
                                animationFrameId = requestAnimationFrame(oneFrame);
                                return;
                            }
                            
                            // Calculate time delta, cap it to prevent large jumps
                            const deltaTime = Math.min((timestamp - lastTimestamp) * 1000, 16000);
                            lastTimestamp = timestamp;
                            accumulatedTime += deltaTime;
                            
                            // Execute in small chunks to prevent browser freezing
                            // Limit to 2ms per frame to keep browser responsive
                            const MAX_TIME_PER_FRAME = 2000; // 2ms in microseconds
                            const CHUNK_SIZE = 1000; // 1ms chunks
                            
                            if (window.vic20 && typeof window.vic20.exec_us === 'function') {
                                while (accumulatedTime > 0) {
                                    const chunkTime = Math.min(accumulatedTime, CHUNK_SIZE);
                                    const startTime = performance.now();
                                    
                                    try {
                                        window.vic20.exec_us(chunkTime);
                                        accumulatedTime -= chunkTime;
                                        
                                        // If execution took too long, stop for this frame
                                        const executionTime = (performance.now() - startTime) * 1000;
                                        if (executionTime > MAX_TIME_PER_FRAME) {
                                            break;
                                        }
                                    } catch (e) {
                                        console.error("VIC-20 iframe: Error in exec_us:", e);
                                        accumulatedTime = 0;
                                        break;
                                    }
                                    
                                    // Don't execute more than MAX_TIME_PER_FRAME per frame
                                    if ((performance.now() - startTime) * 1000 > MAX_TIME_PER_FRAME) {
                                        break;
                                    }
                                }
                                
                                // Cap accumulated time to prevent runaway
                                if (accumulatedTime > 16000) {
                                    accumulatedTime = 16000;
                                }
                            }
                            
                            // Schedule next frame
                            animationFrameId = requestAnimationFrame(oneFrame);
                        }
                        
                        // Start the main loop
                        animationFrameId = requestAnimationFrame(oneFrame);
                        
                        // Store pause/resume functions globally for message handlers
                        window.pauseEmulation = function() {
                            if (!isPaused) {
                                isPaused = true;
                                updateStatus("VIC-20 emulator paused");
                                console.log("VIC-20 iframe: Emulation paused");
                            }
                        };
                        
                        window.resumeEmulation = function() {
                            if (isPaused) {
                                isPaused = false;
                                lastTimestamp = performance.now(); // Reset timestamp on resume
                                updateStatus("VIC-20 emulator resumed");
                                console.log("VIC-20 iframe: Emulation resumed");
                            }
                        };
                        
                        emulatorReady = true;
                        updateStatus("VIC-20 emulator ready - Ready to load programs");
                        
                        // Check for latest compiled program
                        setTimeout(() => window.checkForProgramInURL(), 1000);
                    } else {
                        console.error("VIC-20 iframe: window.vic20 object:", window.vic20);
                        console.error("VIC-20 iframe: Available properties:", Object.keys(window.vic20 || {}));
                        throw new Error("vic20.init() not available after WASM load");
                    }
                } else {
                    throw new Error("load_wasm() function not found");
                }
            } catch (e) {
                updateStatus("Error initializing emulator: " + e.message);
                console.error("VIC-20 iframe: Error initializing emulator:", e);
                
                // Draw error message
                const ctx = canvas.getContext('2d');
                if (ctx) {
                    ctx.fillStyle = 'black';
                    ctx.fillRect(0, 0, canvas.width, canvas.height);
                    ctx.fillStyle = 'red';
                    ctx.font = '16px monospace';
                    ctx.fillText('VIC-20 Emulator Failed to Load', 10, 30);
                    ctx.fillStyle = 'white';
                    ctx.fillText('Error: ' + e.message, 10, 50);
                    ctx.fillText('Check console for details', 10, 70);
                }
            }
        }
        
        // Map browser key events to VIC-20 key codes
        function getVIC20KeyCode(event) {
            // Handle special keys first
            if (event.code === "Space") return 0x20;
            if (event.code === "ArrowLeft") return 0x08;   // Cursor left
            if (event.code === "ArrowRight") return 0x09;   // Cursor right
            if (event.code === "ArrowDown") return 0x0A;   // Cursor down
            if (event.code === "ArrowUp") return 0x0B;     // Cursor up
            if (event.code === "Delete") return 0x01;        // Delete
            if (event.code === "Insert") return 0x07;       // Insert
            if (event.code === "Enter") return 0x0D;        // Return
            if (event.code === "Escape") return 0x03;       // Run/Stop
            if (event.code === "Backquote") return 0x04;    // Left arrow
            if (event.code === "Home") return 0x05;          // Home
            if (event.code === "Backspace" && event.shiftKey) return 0x07;  // Insert (shift+backspace)
            if (event.code === "Backspace" && !event.shiftKey) return 0x01; // Delete
            
            // Function keys
            if (event.code === "F1") return 0xF1;
            if (event.code === "F2") return 0xF2;
            if (event.code === "F3") return 0xF3;
            if (event.code === "F4") return 0xF4;
            if (event.code === "F5") return 0xF5;
            if (event.code === "F6") return 0xF6;
            if (event.code === "F7") return 0xF7;
            if (event.code === "F8") return 0xF8;
            
            // For printable characters, use the character code
            // Shift key is handled by the emulator's keyboard matrix
            if (event.key && event.key.length === 1) {
                return event.key.charCodeAt(0);
            }
            
            return null; // Unknown key
        }
        
        // Add keyboard event listeners directly to canvas
        canvas.addEventListener('keydown', function(event) {
            // Prevent default browser behavior for keys we handle
            if (event.key === ' ' || event.key === 'Backspace' || event.key === 'Tab' || 
                event.key === 'ArrowUp' || event.key === 'ArrowDown' || 
                event.key === 'ArrowLeft' || event.key === 'ArrowRight' ||
                event.key === 'Enter' || event.key === 'Escape' || event.key === 'Home' ||
                event.key === 'Delete' || event.key === 'Insert' || event.key === 'F1' ||
                event.key === 'F2' || event.key === 'F3' || event.key === 'F4' ||
                event.key === 'F5' || event.key === 'F6' || event.key === 'F7' ||
                event.key === 'F8') {
                event.preventDefault();
                event.stopPropagation();
            }
            
            // Disable auto-repeat (handled by emulator)
            if (event.repeat) {
                event.preventDefault();
                return;
            }
            
            // Handle CTRL+ALT+PAUSE for reset
            if (event.code === "Pause" && event.altKey && event.ctrlKey) {
                if (window.vic20 && typeof window.vic20.reset === 'function') {
                    window.vic20.reset();
                    event.preventDefault();
                    return;
                }
            }
            
            // Get VIC-20 key code
            const keyCode = getVIC20KeyCode(event);
            if (keyCode === null) {
                return; // Unknown key, ignore
            }
            
            // Send to emulator
            if (window.vic20 && typeof window.vic20.key_down === 'function') {
                try {
                    window.vic20.key_down(keyCode);
                    console.log("VIC-20 iframe: Sent keydown:", event.key, "->", keyCode);
                } catch (e) {
                    console.error("VIC-20 iframe: Error sending keydown:", e);
                }
            }
        });
        
        canvas.addEventListener('keyup', function(event) {
            // Prevent default browser behavior for keys we handle
            if (event.key === ' ' || event.key === 'Backspace' || event.key === 'Tab' || 
                event.key === 'ArrowUp' || event.key === 'ArrowDown' || 
                event.key === 'ArrowLeft' || event.key === 'ArrowRight' ||
                event.key === 'Enter' || event.key === 'Escape' || event.key === 'Home' ||
                event.key === 'Delete' || event.key === 'Insert' || event.key === 'F1' ||
                event.key === 'F2' || event.key === 'F3' || event.key === 'F4' ||
                event.key === 'F5' || event.key === 'F6' || event.key === 'F7' ||
                event.key === 'F8') {
                event.preventDefault();
                event.stopPropagation();
            }
            
            // Get VIC-20 key code
            const keyCode = getVIC20KeyCode(event);
            if (keyCode === null) {
                return; // Unknown key, ignore
            }
            
            // Send to emulator
            if (window.vic20 && typeof window.vic20.key_up === 'function') {
                try {
                    window.vic20.key_up(keyCode);
                    console.log("VIC-20 iframe: Sent keyup:", event.key, "->", keyCode);
                } catch (e) {
                    console.error("VIC-20 iframe: Error sending keyup:", e);
                }
            }
        });
        
        // Add click event to focus canvas
        // Stop these events from bubbling to parent to prevent pause/resume
        canvas.addEventListener('click', function(event) {
            event.stopPropagation(); // Prevent bubbling to parent window
            event.stopImmediatePropagation(); // Stop other handlers
            canvas.focus();
            updateStatus("Canvas focused - keyboard input enabled");
        }, true); // Use capture phase
        
        // Also focus on mousedown to ensure immediate focus
        canvas.addEventListener('mousedown', function(event) {
            event.stopPropagation(); // Prevent bubbling to parent window
            event.stopImmediatePropagation(); // Stop other handlers
            canvas.focus();
        }, true); // Use capture phase
        
        // Add document-level keyboard listeners as fallback (when canvas doesn't have focus)
        // Only handle if the target is not the canvas (to avoid duplicate events)
        document.addEventListener('keydown', function(event) {
            // If canvas is focused, it will handle the event, so skip here
            if (document.activeElement === canvas) {
                return;
            }
            
            // Focus canvas on any keypress if it's not already focused
            canvas.focus();
            
            // Then let the canvas handler process it
            // (we'll trigger it manually since the event already happened)
            const keyCode = getVIC20KeyCode(event);
            if (keyCode !== null && window.vic20 && typeof window.vic20.key_down === 'function') {
                // Prevent default for keys we handle
                if (event.key === ' ' || event.key === 'Backspace' || event.key === 'Tab' || 
                    event.key === 'ArrowUp' || event.key === 'ArrowDown' || 
                    event.key === 'ArrowLeft' || event.key === 'ArrowRight' ||
                    event.key === 'Enter' || event.key === 'Escape' || event.key === 'Home' ||
                    event.key === 'Delete' || event.key === 'Insert') {
                    event.preventDefault();
                }
                
                // Disable auto-repeat
                if (event.repeat) {
                    event.preventDefault();
                    return;
                }
                
                try {
                    window.vic20.key_down(keyCode);
                    console.log("VIC-20 iframe: Sent keydown (document):", event.key, "->", keyCode);
                } catch (e) {
                    console.error("VIC-20 iframe: Error sending keydown (document):", e);
                }
            }
        });
        
        document.addEventListener('keyup', function(event) {
            // If canvas is focused, it will handle the event, so skip here
            if (document.activeElement === canvas) {
                return;
            }
            
            const keyCode = getVIC20KeyCode(event);
            if (keyCode !== null && window.vic20 && typeof window.vic20.key_up === 'function') {
                // Prevent default for keys we handle
                if (event.key === ' ' || event.key === 'Backspace' || event.key === 'Tab' || 
                    event.key === 'ArrowUp' || event.key === 'ArrowDown' || 
                    event.key === 'ArrowLeft' || event.key === 'ArrowRight' ||
                    event.key === 'Enter' || event.key === 'Escape' || event.key === 'Home' ||
                    event.key === 'Delete' || event.key === 'Insert') {
                    event.preventDefault();
                }
                
                try {
                    window.vic20.key_up(keyCode);
                    console.log("VIC-20 iframe: Sent keyup (document):", event.key, "->", keyCode);
                } catch (e) {
                    console.error("VIC-20 iframe: Error sending keyup (document):", e);
                }
            }
        });
        
        // Add focus/blur events to debug focus state
        // Stop these events from bubbling to parent to prevent pause/resume
        canvas.addEventListener('focus', function(event) {
            event.stopPropagation(); // Prevent bubbling to parent window
            console.log("VIC-20 iframe canvas focused");
            updateStatus("Canvas focused - ready for keyboard input");
        }, true); // Use capture phase
        
        canvas.addEventListener('blur', function(event) {
            event.stopPropagation(); // Prevent bubbling to parent window
            console.log("VIC-20 iframe canvas blurred");
            updateStatus("Canvas blurred - keyboard input disabled");
        }, true); // Use capture phase
        
        // Make sure the document can receive focus
        document.addEventListener('click', function(event) {
            if (event.target === document.body) {
                canvas.focus();
                console.log("VIC-20 iframe: Clicked on body, focusing canvas");
            }
        });
        
        // Listen for messages from parent window
        window.addEventListener('message', function(event) {
            if (event.data && event.data.type === 'compiled_program') {
                updateStatus("Received compiled program: " + event.data.program.length + " bytes");
                lastCompiledProgram = event.data.program;
                
                // Auto-load if requested
                if (event.data.autoLoad && emulatorReady) {
                    loadProgramIntoEmulator(event.data.program);
                }
            } else if (event.data && event.data.type === 'compiled_program_response') {
                updateStatus("Received program response: " + event.data.program.length + " bytes");
                lastCompiledProgram = event.data.program;
                
                if (emulatorReady) {
                    loadProgramIntoEmulator(event.data.program);
                }
            } else if (event.data && event.data.type === 'pause') {
                console.log("VIC-20 iframe: Received pause command");
                updateStatus("Pausing VIC-20 emulator...");
                
                if (typeof window.pauseEmulation === 'function') {
                    window.pauseEmulation();
                } else {
                    console.log("VIC-20 iframe: Pause function not available");
                    updateStatus("Pause not available");
                }
            } else if (event.data && event.data.type === 'resume') {
                console.log("VIC-20 iframe: Received resume command");
                updateStatus("Resuming VIC-20 emulator...");
                
                if (typeof window.resumeEmulation === 'function') {
                    window.resumeEmulation();
                } else {
                    console.log("VIC-20 iframe: Resume function not available");
                    updateStatus("Resume not available");
                }
            }
        });
        
        // Global function that can be called from main application
        window.sendCompiledProgramToIframe = function(programData) {
            if (programData && programData.length > 0) {
                lastCompiledProgram = programData;
                updateStatus("Received program via global function: " + programData.length + " bytes");
                
                if (emulatorReady) {
                    loadProgramIntoEmulator(programData);
                }
            } else {
                updateStatus("Invalid program data received");
            }
        };
        
        // Global function to get program data from main app
        window.getCompiledProgramFromMainApp = function() {
            console.log("VIC-20 iframe: Attempting to get program from main app...");
            
            // Try to access the main application's worker
            if (window.parent && window.parent.worker && window.parent.worker.store && window.parent.worker.store.workfs) {
                if (window.parent.worker.store.workfs['main']) {
                    const mainFile = window.parent.worker.store.workfs['main'];
                    lastCompiledProgram = mainFile.data;
                    updateStatus("Got program from main app: " + mainFile.data.length + " bytes");
                    
                    if (emulatorReady) {
                        loadProgramIntoEmulator(mainFile.data);
                    }
                    return true;
                }
            }
            
            updateStatus("Could not get program from main app - use Manual Load");
            return false;
        };
        
        // Initialize when page loads
        window.addEventListener('load', function() {
            initVIC20Emulator();
            
            // Check for program data in URL parameters
            checkForProgramInURL();
        });
        
        function checkForProgramInURL() {
            console.log("VIC-20 iframe: Checking for program in URL parameters...");
            console.log("VIC-20 iframe: Current URL:", window.location.href);
            console.log("VIC-20 iframe: Search params:", window.location.search);
            
            const urlParams = new URLSearchParams(window.location.search);
            const programData = urlParams.get('program');
            const programHex = urlParams.get('hex');
            const inputText = urlParams.get('input');
            
            console.log("VIC-20 iframe: program param:", programData ? "found (" + programData.length + " chars)" : "not found");
            console.log("VIC-20 iframe: hex param:", programHex ? "found (" + programHex.length + " chars)" : "not found");
            console.log("VIC-20 iframe: input param:", inputText ? "found (" + inputText.length + " chars)" : "not found");
            
            if (programData) {
                try {
                    console.log("VIC-20 iframe: Attempting to decode base64 program data...");
                    // Try to decode base64 program data
                    const binaryData = atob(programData);
                    console.log("VIC-20 iframe: Base64 decoded to binary data:", binaryData.length, "bytes");
                    
                    const programArray = new Uint8Array(binaryData.length);
                    for (let i = 0; i < binaryData.length; i++) {
                        programArray[i] = binaryData.charCodeAt(i);
                    }
                    
                    console.log("VIC-20 iframe: Found program in URL (base64): " + programArray.length + " bytes");
                    console.log("VIC-20 iframe: First 16 bytes:", Array.from(programArray.slice(0, 16)).map(b => b.toString(16).padStart(2, '0')).join(' '));
                    
                    lastCompiledProgram = programArray;
                    updateStatus("Program loaded from URL: " + programArray.length + " bytes");
                    
                    // Auto-load when emulator is ready
                    if (emulatorReady) {
                        console.log("VIC-20 iframe: Emulator ready, auto-loading program...");
                        setTimeout(() => loadProgramIntoEmulator(programArray), 500);
                    } else {
                        console.log("VIC-20 iframe: Emulator not ready yet, will auto-load when ready");
                    }
                    
                } catch (e) {
                    console.error("VIC-20 iframe: Error decoding base64 program data:", e);
                    updateStatus("Error decoding program from URL: " + e.message);
                }
            } else if (programHex) {
                try {
                    console.log("VIC-20 iframe: Attempting to parse hex program data...");
                    // Parse hex string from URL
                    const hexBytes = programHex.trim().split(/\s+/);
                    console.log("VIC-20 iframe: Hex bytes array:", hexBytes.length, "bytes");
                    
                    const programArray = new Uint8Array(hexBytes.map(byte => parseInt(byte, 16)));
                    
                    console.log("VIC-20 iframe: Found program in URL (hex): " + programArray.length + " bytes");
                    console.log("VIC-20 iframe: First 16 bytes:", Array.from(programArray.slice(0, 16)).map(b => b.toString(16).padStart(2, '0')).join(' '));
                    
                    lastCompiledProgram = programArray;
                    updateStatus("Program loaded from URL (hex): " + programArray.length + " bytes");
                    
                    // Auto-load when emulator is ready
                    if (emulatorReady) {
                        console.log("VIC-20 iframe: Emulator ready, auto-loading program...");
                        setTimeout(() => loadProgramIntoEmulator(programArray), 500);
                    } else {
                        console.log("VIC-20 iframe: Emulator not ready yet, will auto-load when ready");
                    }
                    
                } catch (e) {
                    console.error("VIC-20 iframe: Error parsing hex program data:", e);
                    updateStatus("Error parsing hex program from URL: " + e.message);
                }
            } else if (inputText) {
                // Handle BASIC program input via ?input= parameter
                console.log("VIC-20 iframe: Found input parameter, will type into emulator");
                updateStatus("BASIC program found in URL, will type into emulator");
                
                // Decode the URL-encoded input text
                const decodedText = decodeURIComponent(inputText);
                console.log("VIC-20 iframe: Decoded input text length:", decodedText.length, "characters");
                
                // Store the input text for typing when emulator is ready
                const typeTextIntoEmulator = (text) => {
                    console.log("VIC-20 iframe: Typing text into emulator:", text.substring(0, 50) + "...");
                    
                    if (!window.h) {
                        console.error("VIC-20 iframe: Emulator not available for typing");
                        updateStatus("Emulator not ready for typing");
                        return;
                    }
                    
                    // Function to type a single character
                    const typeChar = (char, delay) => {
                        return new Promise((resolve) => {
                            setTimeout(() => {
                                const charCode = char.charCodeAt(0);
                                
                                // Try setKeyInput function first
                                if (typeof window.h.setKeyInput === 'function') {
                                    try {
                                        // Send keydown
                                        window.h.setKeyInput(charCode, charCode, 1);
                                        // Send keyup after a short delay
                                        setTimeout(() => {
                                            window.h.setKeyInput(charCode, charCode, 2);
                                            resolve();
                                        }, 50);
                                    } catch (e) {
                                        console.error("VIC-20 iframe: Error typing character:", e);
                                        resolve();
                                    }
                                } else if (typeof window.h._ === 'function') {
                                    // Try alternative function
                                    try {
                                        window.h._(canvas, charCode, 2, 0);
                                        setTimeout(() => {
                                            window.h.Z(canvas, charCode, 3, 0);
                                            resolve();
                                        }, 50);
                                    } catch (e) {
                                        console.error("VIC-20 iframe: Error typing character:", e);
                                        resolve();
                                    }
                                } else {
                                    console.error("VIC-20 iframe: No keyboard input function available");
                                    resolve();
                                }
                            }, delay);
                        });
                    };
                    
                    // Type each character with a delay
                    let promise = Promise.resolve();
                    for (let i = 0; i < text.length; i++) {
                        const char = text[i];
                        const delay = char === '\n' ? 200 : 100; // Longer delay for newlines
                        promise = promise.then(() => typeChar(char, delay));
                    }
                    
                    promise.then(() => {
                        console.log("VIC-20 iframe: Finished typing text into emulator");
                        updateStatus("BASIC program typed into emulator");
                    });
                };
                
                // Wait for emulator to be ready, then type the text
                if (emulatorReady) {
                    console.log("VIC-20 iframe: Emulator ready, typing input text...");
                    setTimeout(() => typeTextIntoEmulator(decodedText), 1000);
                } else {
                    console.log("VIC-20 iframe: Emulator not ready yet, will type when ready");
                    // Store the function to call when ready
                    const originalCheckReady = setInterval(() => {
                        if (emulatorReady) {
                            clearInterval(originalCheckReady);
                            setTimeout(() => typeTextIntoEmulator(decodedText), 1000);
                        }
                    }, 100);
                }
            } else {
                console.log("VIC-20 iframe: No program parameters found in URL");
            }
        }
    </script>
</body>
</html> 